#include <iostream.h>#include <XPCConnectInfo.h>#include <XPCClientConnection.h>#include <XPCHeader.h>#include <XPCMsg.h>#ifdef UNIX    #include <XPCPthread.h>#else    #include <XPCThread.h>#endif// Process connection thread external definition#ifdef UNIXvoid *vProcessConnect(void *_vArg);#elseDWORD WINAPI vProcessConnect(void *_vArg);#endif// First element of the XPCClientConnection linked-listXPCClientConnection *firstClient;main(){    // Constructs a private semaphore initialized as unlocked    XPCSemaphore listSem(PRIVATE_SEM, (unsigned int)1);    try    {        // Constructs a TCP socket         XPCTcpSocket serverSocket((long int)6800);        // Binds to the socket and listens for incoming connections        serverSocket.vBindSocket();        serverSocket.vListen(5);        while(1)        {            // Accept connecting clients            XPCTcpSocket *newConnection = serverSocket.Accept();            // Construct a XPCConnectInfo object using the TCP connection andthe semaphore            XPCConnectInfo *connectInfo = new XPCConnectInfo(newConnection,&listSem);            // Spawn a thread to process the connected client#ifdef UNIX            XPCPthread<int> connectThread(vProcessConnect, (void *)connectInfo);#else            XPCThread connectThread(vProcessConect, (void *)connectInfo);#endif        }    }    catch(XPCException &exceptObject)    {        cout << exceptObject.sGetException() << endl;    }}void vDeleteConnection(XPCConnectInfo *_connectInfo){    // Remove a connection from the linked-list    // The current element in the traversal of the linked-list    XPCClientConnection *currentClient;    // Before the linked list is accessed the semaphore is locked    _connectInfo->getSem()->vLockWait();    // The linked-list is traversed.  If the client is found it is removed fromthe linked-list    currentClient = firstClient;    XPCClientConnection *previousClient = firstClient;    while(currentClient != NULL)    {        if (currentClient->getSocket()->iGetSocketFd() ==_connectInfo->getSocket()->iGetSocketFd())        {            if (currentClient == firstClient)            {                currentClient = firstClient;                previousClient = currentClient;            }            else            {                previousClient->next = currentClient->next;                currentClient = previousClient->next;            }         }         else         {             previousClient = currentClient;             currentClient = currentClient->next;         }     }     // After the linked-list has been processed the semaphore is unlocked     _connectInfo->getSem()->vUnlock();}#ifdef UNIXvoid *vProcessConnect(void *_vArg)#elseDWORD WINAPI vProcessConnect(void *_vARG)#endif{    // The XPCConnectInfo object is cast back to its original form    XPCConnectInfo *connectInfo = (XPCConnectInfo *)_vArg;    XPCHeader aHeader;    // A XPCHeader object is constructed    int iNumBytes;        // The number of bytes received from the socket    // The current pointer within the linked-list of XPCClientConnection objects    XPCClientConnection *currentClient;    try    {        while(1)        {            // Receive a XPCHeader object from the socket            iNumBytes = connectInfo->getSocket()->iRecieveMessage((void*)&aHeader, sizeof(XPCHeader), MSG_WAITALL);            // If the client has disconnected, the client's connection isremoved from the linked-list            if ((iNumBytes == 0) && (errno == ECONNRESET))            {                vDeleteConnection(connectInfo);                delete connectInfo;                return 1;            }            // If a error occurred receiving the XPCHeader message, the clientis removed fromt the            // linked-list            else if (iNumBytes == 0)            {                vDeleteConnection(connectInfo);                delete connectInfo;                return 1;            }            if (aHeader.cGetType() == SUBSCRIBE)            {                // If the message is a SUBSCRIBE message the socket filedescriptor and message                // name of the client are stored within the linked-list ofclient connections                // The semaphore is locked                connectInfo->getSem()->vLockWait();                if (firstClient == NULL)                {                    firstClient = newXPCClientConnection(aHeader.sGetSubscription(), connectInfo->getSocket());                    currentClient = firstClient;                    currentClient->next = NULL;                }                else                {                    currentClient = firstClient;                    while (currentClient->next != NULL)                    currentClient = currentClient->next;                                XPCClientConnection *newClient = newXPCClientConnection(aHeader.sGetSubscription(), connectInfo->getSocket());                    currentClient->next = newClient;                    currentClient = currentClient->next;                    currentClient->next = NULL;                }                // The semaphore is unlocked                connectInfo->getSem()->vUnlock();            }            else if (aHeader.cGetType() == PUBLISH)            {                // If the message is a PUBLISH message, all clients subscribedto the messsage                // are found and forwarded the message                cout << aHeader.iGetNumComponents() << " Parts" << endl;                // The semaphore is locked                connectInfo->getSem()->vLockWait();                // A XPCMessage object is constructed                XPCMessage newMessage(aHeader.iGetNumComponents(),connectInfo->getSocket(), aHeader.sGetSubscription());                currentClient = firstClient;                while(currentClient != NULL)                {                    if (strcmp(currentClient->sGetSubscribe(),aHeader.sGetSubscription()) == 0)                    {                        currentClient->getSocket()->iSendMessage((void*)&aHeader, sizeof(XPCHeader));                        for (int iCount = 0; iCount <aHeader.iGetNumComponents(); iCount++)                            currentClient->getSocket()->iSendMessage((void*)newMessage.ContainerList[iCount], sizeof(XPCContainer));                    }                    currentClient = currentClient->next;                }                                // The semaphore is unlocked                connectInfo->getSem()->vUnlock();            }        }    }    catch(XPCException &exceptOb)    {        cout << exceptOb.sGetException() << endl;        connectInfo->getSem()->vUnlock();        vDeleteConnection(connectInfo);        delete connectInfo;        return 1;    }}    
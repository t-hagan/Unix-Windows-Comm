#include <iostream.h>#include <XPCMsg.h>#include <XPCConnectInfo.h>#include <XPCClientConnection.h>#include <XPCThread.h>// Process connection thread external definition#ifdef UNIXvoid *vProcessConnect(void *_vArg);#elseDWORD WINAPI vProcessConnect(void *_vArg);#endif// First element of the XPCClientConnection linked-listXPCClientConnection *firstClient;main(){        try        {    // Constructs a private semaphore initialized as unlocked#ifdef UNIX    XPCSemaphore listSem(PRIVATE_SEM, (unsigned int)1);#else    XPCSemaphore listSem("ListSem", 1, 1, CREATE_SEM);    // Initialize the WinSock library    WSADATA wsaData;    if (WSAStartup(0x101, &wsaData) != 0)    {        cout << "Error initializing WinSock library: " << WSAGetLastError() <<endl;        return 0;    }#endif        // Constructs a TCP socket         XPCTcpSocket serverSocket((long int)6800);        // Binds to the socket and listens for incoming connections        serverSocket.vBindSocket();        serverSocket.vListen(5);        while(1)        {            // Accept connecting clients            XPCTcpSocket *newConnection = serverSocket.Accept();            // Construct a XPCConnectInfo object using the TCP connection andthe semaphore            XPCConnectInfo *connectInfo = new XPCConnectInfo(newConnection,&listSem);            // Spawn a thread to process the connected client#ifdef UNIX            XPCthread<int> connectThread(vProcessConnect, (void *)connectInfo);#else            XPCThread connectThread(vProcessConnect, (void *)connectInfo);#endif        }    }    catch(XPCException &exceptObject)    {            cout << exceptObject.sGetException() << endl;    }}void vDeleteConnection(XPCConnectInfo *_connectInfo){    // Remove a connection from the linked-list    // The current element in the traversal of the linked-list    XPCClientConnection *currentClient;    // Before the linked list is accessed the semaphore is locked    _connectInfo->getSem()->vLockWait();    // The linked-list is traversed.  If the client is found it is removed fromthe linked-list    currentClient = firstClient;    XPCClientConnection *previousClient = firstClient;    while(currentClient != NULL)    {        if (currentClient->getSocket()->iGetSocketFd() ==_connectInfo->getSocket()->iGetSocketFd())        {            cout << "Found subscribed socket and removing" << endl;            if (currentClient == firstClient)            {                cout << "Removing ID in first" <<_connectInfo->getSocket()->iGetSocketFd() << endl;                firstClient = firstClient->next;                currentClient = firstClient;                previousClient = currentClient;            }            else            {                cout << "Removing ID " <<_connectInfo->getSocket()->iGetSocketFd() << endl;                previousClient->next = currentClient->next;                currentClient = previousClient->next;            }         }         else         {             previousClient = currentClient;             currentClient = currentClient->next;         }     }    // After the linked-list has been processed the semaphore is unlocked     _connectInfo->getSem()->vUnlock();}#ifdef UNIXvoid *vProcessConnect(void *_vArg)#elseDWORD WINAPI vProcessConnect(void *_vArg)#endif{    // The XPCConnectInfo object is cast back to its original form    XPCConnectInfo *connectInfo = (XPCConnectInfo *)_vArg;    XPCHeader aHeader;    // A XPCHeader object is constructed    int iNumBytes;        // The number of bytes received from the socket    // The current pointer within the linked-list of XPCClientConnection objects    XPCClientConnection *currentClient;    try    {        while(1)        {            // Receive a XPCHeader object from the socket            iNumBytes = connectInfo->getSocket()->iRecieveMessage((void*)&aHeader, sizeof(XPCHeader), MSG_WAITALL);            // If the client has disconnected, the client's connection isremoved from the linked-list#ifdef UNIX            if ((iNumBytes == 0) && (errno == ECONNRESET))#else            if ((iNumBytes == 0) && (WSAGetLastError() == WSAECONNRESET))#endif            {                cout << "Lost client connection" << endl;                vDeleteConnection(connectInfo);                delete connectInfo;                cout << "Exiting Thread" << endl;                return 1;            }            // If a error occurred receiving the XPCHeader message, the clientis removed fromt the            // linked-list            else if (iNumBytes == 0)            {                cout << "Error occurred with connected client: " <<strerror(errno) << endl;                vDeleteConnection(connectInfo);                delete connectInfo;                cout << "Exiting Thread" << endl;                return 1;            }            cout << "Got New Request" << endl;            if (aHeader.cGetType() == SUBSCRIBE)            {                // If the message is a SUBSCRIBE message the socket filedescriptor and message                // name of the client are stored within the linked-list ofclient connections                cout << "Received new subscription: " <<aHeader.sGetSubscription() << endl;                // The semaphore is locked                connectInfo->getSem()->vLockWait();                if (firstClient == NULL)                {                    cout << "Storing ID in first" <<connectInfo->getSocket()->iGetSocketFd() << endl;                    firstClient = newXPCClientConnection(aHeader.sGetSubscription(), connectInfo->getSocket());                    currentClient = firstClient;                    currentClient->next = NULL;                }                else                {                    currentClient = firstClient;                    while (currentClient->next != NULL)                            currentClient = currentClient->next;                    XPCClientConnection *newClient = newXPCClientConnection(aHeader.sGetSubscription(), connectInfo->getSocket());                    currentClient->next = newClient;                    currentClient = currentClient->next;                    currentClient->next = NULL;                }                // The semaphore is unlocked                connectInfo->getSem()->vUnlock();            }            else if (aHeader.cGetType() == PUBLISH)            {                // If the message is a PUBLISH message, all clients subscribedto the messsage                // are found and forwarded the message                cout << "Got publication: " << aHeader.sGetSubscription() <<endl;                cout << aHeader.iGetNumComponents() << " Parts" << endl;                // The semaphore is locked                connectInfo->getSem()->vLockWait();                        //      Sleep(100);                // A XPCMessage object is constructed                XPCMessage newMessage(aHeader.iGetNumComponents(),connectInfo->getSocket(), aHeader.sGetSubscription());                currentClient = firstClient;                while(currentClient != NULL)                {                    if (strcmp(currentClient->sGetSubscribe(),aHeader.sGetSubscription()) == 0)                    {                        cout << "Found subscription.  Sending Message" << endl;                        currentClient->getSocket()->iSendMessage((void*)&aHeader, sizeof(XPCHeader));                        for (int iCount = 0; iCount <aHeader.iGetNumComponents(); iCount++)                            currentClient->getSocket()->iSendMessage((void*)newMessage.ContainerList[iCount], sizeof(XPCContainer));                    }                    currentClient = currentClient->next;                }                                // The semaphore is unlocked                connectInfo->getSem()->vUnlock();                                Sleep(300);            }        }    }     catch(XPCException &exceptOb)    {        cout << exceptOb.sGetException() << endl;                connectInfo->getSem()->vUnlock();        vDeleteConnection(connectInfo);        delete connectInfo;        cout << "Exiting Thread" << endl;        return 1;    }    return 1;}    